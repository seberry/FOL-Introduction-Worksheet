<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Modal Non-Entailment Worksheet</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f4f6;
      color: #111827;
    }

    #layout {
      display: grid;
      grid-template-columns: 260px minmax(0, 1fr);
      grid-template-rows: auto;
      height: 100vh;
    }

    aside {
      border-right: 1px solid #e5e7eb;
      background: #111827;
      color: #e5e7eb;
      padding: 1rem;
      overflow-y: auto;
    }

    aside h2 {
      margin-top: 0;
      font-size: 1.1rem;
      margin-bottom: 0.75rem;
    }

    .problem-button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 0.4rem 0.6rem;
      border-radius: 0.375rem;
      border: none;
      margin-bottom: 0.3rem;
      background: #1f2937;
      color: inherit;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .problem-button.active {
      background: #2563eb;
    }

    .problem-button .status {
      margin-right: 0.35rem;
    }

    main {
      padding: 1rem 1.25rem;
      overflow-y: auto;
    }

    main h1 {
      margin-top: 0;
      font-size: 1.25rem;
    }

    .constraint-list {
      font-size: 0.9rem;
      padding-left: 1.1rem;
    }

    .constraint-list li {
      margin-bottom: 0.25rem;
    }

    .check-button {
      margin-top: 0.75rem;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
      border: none;
      background: #16a34a;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .check-button:hover {
      background: #15803d;
    }

    #result {
      margin-top: 0.75rem;
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem;
      border-radius: 0.5rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      white-space: pre-wrap;
    }

    #playground-panel {
        margin-top: 1.25rem;
        background: #ffffff;
        border-radius: 0.75rem;
        border: 1px solid #e5e7eb;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }


    #playground-header {
        padding: 0.5rem 0.75rem;
        border-bottom: 1px solid #e5e7eb;
        font-size: 0.9rem;
        background: #f9fafb;
        }

    #playground-frame {
        border: none;
        width: 100%;
        height: 700px;
        border: none;
    }
  </style>
</head>
<body>

<div id="layout">
  <!-- Sidebar: problem list -->
  <aside>
    <h2>Problems</h2>
    <div id="problem-list"></div>
  </aside>

  <!-- Middle: active problem -->
  <main>
    <h1 id="problem-title">Modal non-entailment worksheet</h1>
    <div id="problem-description"></div>

    <h3>Constraints to satisfy</h3>
    <ul id="constraint-list" class="constraint-list"></ul>

    <button class="check-button" onclick="checkCurrentProblem()">Check current model</button>

    <div id="result"></div>

    <section id="playground-panel">
      <div id="playground-header">
        Build a Kripke model that makes the premise true at w₀ and the conclusion false,
        showing the sequent is invalid in K. Then click “Check current model”.
      </div>
      <iframe
        id="playground-frame"
        src="modallogic/index.html"
        title="Modal Logic Playground"
      ></iframe>
      <div style="
  text-align: right;
  font-size: 0.75rem;
  color: #6b7280;
  padding: 0.35rem 0.75rem 0.45rem;
  border-top: 1px solid #e5e7eb;
">
  Model editor based on
  <a href="https://github.com/rkirsling/modallogic" target="_blank"
     style="color: #2563eb; text-decoration: none;">
    Ross Kirsling’s Modal Logic Playground
  </a>.
</div>
    </section>
  </main>


</div>

<script>
  // --- Problem definitions ---------------------------------------------------

  // Each problem records the premise that must be true at w0 and the
  // conclusion that must be false at w0 to witness non-entailment.
  const problems = [
    {
      id: 1,
      title: "1. □(A ∨ B) ⊭ □A",
      description: `Show a model where □(A ∨ B) is true at w₀ but □A is false.`,
      constraints: [
        { type: "truth", world: 0, formula: "[](A | B)", expected: true },
        { type: "truth", world: 0, formula: "[]A", expected: false }
      ],
      modelString: null,
      solved: false
    },
    {
      id: 2,
      title: "2. □¬(P ∧ Q) ⊭ (□¬P ∨ □¬Q)",
      description: `Make □¬(P ∧ Q) true at w₀ while (□¬P ∨ □¬Q) is false at w₀.`,
      constraints: [
        { type: "truth", world: 0, formula: "[]~(P & Q)", expected: true },
        { type: "truth", world: 0, formula: "([]~P | []~Q)", expected: false }
      ],
      modelString: null,
      solved: false
    },
    {
      id: 3,
      title: "3. □X ⊭ X",
      description: `Find a world w₀ where □X holds but X itself is false.`,
      constraints: [
        { type: "truth", world: 0, formula: "[]X", expected: true },
        { type: "truth", world: 0, formula: "X", expected: false }
      ],
      modelString: null,
      solved: false
    },
    {
      id: 4,
      title: "4. X ⊭ ◇X",
      description: `Make X true at w₀ while ◇X fails at w₀.`,
      constraints: [
        { type: "truth", world: 0, formula: "X", expected: true },
        { type: "truth", world: 0, formula: "<>X", expected: false }
      ],
      modelString: null,
      solved: false
    },
    {
      id: 5,
      title: "5. □M ⊭ □□M",
      description: `Ensure □M is true at w₀ but □□M is false at w₀.`,
      constraints: [
        { type: "truth", world: 0, formula: "[]M", expected: true },
        { type: "truth", world: 0, formula: "[][]M", expected: false }
      ],
      modelString: null,
      solved: false
    },
    {
      id: 6,
      title: "6. ◇M ⊭ □◇M",
      description: `Build a model where ◇M holds at w₀ but □◇M does not.`,
      constraints: [
        { type: "truth", world: 0, formula: "<>M", expected: true },
        { type: "truth", world: 0, formula: "[]<>M", expected: false }
      ],
      modelString: null,
      solved: false
    }
  ];

  let activeIndex = 0;

  // --- Helper: render problem list ------------------------------------------

  function renderProblemList() {
    const list = document.getElementById("problem-list");
    list.innerHTML = "";
    problems.forEach((p, idx) => {
      const btn = document.createElement("button");
      btn.className = "problem-button" + (idx === activeIndex ? " active" : "");
      const status = p.solved ? "✅" : "⬜";
      btn.innerHTML = `<span class="status">${status}</span>${p.title}`;
      btn.onclick = () => setActiveProblem(idx);
      list.appendChild(btn);
    });
  }

  // --- Helper: render active problem ----------------------------------------

  function setActiveProblem(index) {
    activeIndex = index;
    renderProblemList();

    const p = problems[activeIndex];

    document.getElementById("problem-title").textContent = p.title;
    document.getElementById("problem-description").textContent = p.description.trim();

    const ul = document.getElementById("constraint-list");
    ul.innerHTML = "";
    for (const c of p.constraints) {
      const li = document.createElement("li");
      if (c.type === "truth") {
        li.textContent = `At w0: ${c.formula} should be ${c.expected ? "true" : "false"}.`;
      } else if (c.type === "different") {
        li.textContent = `At w0: ${c.formulaA} and ${c.formulaB} must have different truth values.`;
      }
      ul.appendChild(li);
    }

    document.getElementById("result").textContent = "";

    // Load model into iframe: either the stored one or the default
    const frame = document.getElementById("playground-frame");
    let url = "modallogic/index.html";
    if (p.modelString) {
      url += "?model=" + encodeURIComponent(p.modelString);
    }
    frame.src = url;
  }

  // --- Forall x style pretty-print ------------------------------------------

  function formatModelForForallX(model) {
    const states = model.getStates();
    const worldIndices = [];
    for (let i = 0; i < states.length; i++) {
      if (states[i] !== null && states[i] !== undefined) {
        worldIndices.push(i);
      }
    }

    // Worlds: W: 1,2,...
    const W = "W: " + (worldIndices.length ? worldIndices.map(i => i + 1).join(", ") : "—");

    // Accessibility relation R
    const pairs = [];
    for (const i of worldIndices) {
      const succ = model.getSuccessorsOf(i);
      for (const j of succ) {
        if (worldIndices.includes(j)) {
          pairs.push(`⟨${i + 1},${j + 1}⟩`);
        }
      }
    }
    const R = "R: " + (pairs.length ? pairs.join(", ") : "—");

    // Valuation ν
    const varsSet = new Set();
    for (const st of states) {
      if (st) {
        for (const v in st) varsSet.add(v);
      }
    }
    const vars = Array.from(varsSet).sort();
    const nuParts = [];
    for (const i of worldIndices) {
      const st = states[i] || {};
      for (const v of vars) {
        const val = !!st[v];
        nuParts.push(`ν${i + 1}(${v}) = ${val ? "T" : "F"}`);
      }
    }
    const nu = "ν: " + (nuParts.length ? nuParts.join(", ") : "—");

    return `${W}\n${R}\n${nu}`;
  }

  // --- Core: check current model against constraints ------------------------

  function checkCurrentProblem() {
    const frame = document.getElementById("playground-frame");
    const win = frame.contentWindow;

    if (!win || !win.MPL || !win.model) {
      alert("Playground not ready yet — try again in a moment.");
      return;
    }

    const p = problems[activeIndex];
    const model = win.model;
    const MPL = win.MPL;

    // Persist model so when we switch away and back, we reload it
    p.modelString = model.getModelString();

    let allOk = true;
    const lines = [];

    for (const c of p.constraints) {
      if (c.type === "truth") {
        const wff = new MPL.Wff(c.formula);
        const val = MPL.truth(model, c.world, wff);
        const ok = (val === c.expected);
        allOk = allOk && ok;
        lines.push(
          `At w${c.world + 1}: ${c.formula} is ${val ? "T" : "F"} (expected ${c.expected ? "T" : "F"})`
        );
      } else if (c.type === "different") {
        const fA = new MPL.Wff(c.formulaA);
        const fB = new MPL.Wff(c.formulaB);
        const valA = MPL.truth(model, c.world, fA);
        const valB = MPL.truth(model, c.world, fB);
        const ok = (valA !== valB);
        allOk = allOk && ok;
        lines.push(
          `At w${c.world }: ${c.formulaA} = ${valA ? "T" : "F"}, ` +
          `${c.formulaB} = ${valB ? "T" : "F"} (need them to differ)`
        );
      }
    }

    p.solved = allOk;
    renderProblemList();

    let out = lines.join("\n") + "\n\n";
    if (allOk) {
      out += "✅ Solved!\n\nModel in Forall x style:\n";
      out += formatModelForForallX(model);
    } else {
      out += "❌ Not yet — adjust your model and try again.";
    }

    document.getElementById("result").textContent = out;
  }

  // --- Init ------------------------------------------------------------------

  window.addEventListener("load", () => {
    renderProblemList();
    setActiveProblem(0);
  });
</script>

<script>
function resizePlayground() {
  const iframe = document.getElementById('playground-frame');
  if (!iframe) return;
  try {
    const innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    iframe.style.height = innerDoc.body.scrollHeight + "px";
  } catch (e) {
    // silently fail if cross-origin (should not happen here)
  }
}

// Resize once when iframe loads
document.getElementById('playground-frame').addEventListener('load', resizePlayground);
</script>

</body>
</html>
